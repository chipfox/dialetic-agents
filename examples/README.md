# Dialectical Loop Examples

This directory contains example inputs and outputs from successful dialectical loop runs.

## Example: User Profile Feature

This example demonstrates a typical 5-turn workflow implementing a user profile page in a Next.js application.

### Files

- **[REQUIREMENTS.md](REQUIREMENTS.md)** - High-level user requirements and acceptance criteria
- **[SPECIFICATION.md](SPECIFICATION.md)** - Detailed technical specification generated by Architect agent
- **[dialectical-loop-success.json](dialectical-loop-success.json)** - Complete run log showing all events, tokens, and outcomes

### Workflow Summary

**Turn 0 (Architect):**

- Generated detailed 5-turn implementation plan
- Defined file structure and component architecture
- Specified validation rules and acceptance criteria

**Turn 1 (Player → Coach):**

- Created type definitions and basic page structure
- Coach blocked: Missing ProfileCard and ProfileEditForm components

**Turn 2 (Player → Coach):**

- Implemented both missing components
- Coach blocked: Form validation not implemented

**Turn 3 (Player → Coach):**

- Added client-side validation logic
- Coach blocked: Success message missing

**Turn 4 (Player → Coach):**

- Implemented success message with auto-dismiss
- Coach blocked: SPECIFICATION.md not updated with progress markers

**Turn 5 (Player → Coach):**

- Updated SPECIFICATION.md with [DONE] markers
- Coach approved: All acceptance criteria met ✅

### Key Metrics

- **Total Duration:** 17 minutes
- **Turns to Approval:** 5 (optimal)
- **Total Token Estimate:** ~52,900 tokens
- **Files Created:** 4 (types, page, 2 components)
- **Files Edited:** 3 (including SPECIFICATION updates)
- **Verification Success Rate:** 100%
- **Inter-agent Feedback Coverage:** 94%

### Lessons from This Run

**What Went Well:**

- Architect provided clear, actionable 5-turn plan
- Player implemented incrementally (one blocker per turn)
- Coach feedback was specific and prioritized
- Token-saving strategy worked (SPECIFICATION pruning)
- Verification passed on every turn

**Token Optimizations Used:**

- Lean mode enabled (--lean-mode)
- Fast-fail optimization (skip Coach when verification fails)
- Auto-context switching (full snapshot → git-changed)
- Coach focus-recent mode (only changed files)
- Specification pruning (removed completed details)

**Convergence Pattern:**

- Turn 1: Establish baseline (types + page)
- Turn 2: Add UI components
- Turn 3: Add validation logic
- Turn 4: Add success feedback
- Turn 5: Clean up and mark complete

This demonstrates the ideal workflow: steady progress, minimal rework, efficient token usage, and completion within the 5-turn budget.

## Running This Example

To reproduce a similar workflow:

```bash
# 1. Create REQUIREMENTS.md in your project
cp examples/REQUIREMENTS.md ./REQUIREMENTS.md

# 2. Run dialectical loop
python ~/.claude/skills/dialectical-loop/scripts/dialectical_loop.py \
  --max-turns 10 \
  --lean-mode \
  --verbose

# 3. Review the generated log
cat dialectical-loop-*.json | jq '.metrics'
```

## Understanding the Log Format

The JSON log contains:

- **events[]** - Chronological list of all agent actions, verifications, and outcomes
- **metrics** - Token usage, file operations, command results, loop health indicators
- **loop_health** - Warnings about stuck patterns, zero-edit streaks, or spiraling failures
- **final_state** - Summary of completion status and approval reason

Use the log to:

- Debug why a run failed or got stuck
- Optimize token usage by reviewing agent context sizes
- Analyze convergence velocity and identify bottlenecks
- Track inter-agent communication patterns
